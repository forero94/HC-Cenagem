const fs = require('fs');
const path = require('path');

const SCHEMA_PATH = path.join(
  __dirname,
  '..',
  'cenagem-backend',
  'openapi',
  'case-wizard.schema.json',
);

const OUTPUT_PATH = path.join(
  __dirname,
  '..',
  'cenagem-registro',
  'src',
  'components',
  'NewCase',
  'caseWizard.generated.ts',
);

const MESSAGES_PATH = path.join(
  __dirname,
  '..',
  'cenagem-backend',
  'openapi',
  'case-wizard.messages.json',
);

const FRONT_MESSAGES_OUTPUT_PATH = path.join(
  __dirname,
  '..',
  'cenagem-registro',
  'src',
  'components',
  'NewCase',
  'caseWizard.messages.ts',
);

const BACKEND_MESSAGES_OUTPUT_PATH = path.join(
  __dirname,
  '..',
  'cenagem-backend',
  'libs',
  'common',
  'src',
  'case-wizard',
  'messages.ts',
);

function loadSchema() {
  const raw = fs.readFileSync(SCHEMA_PATH, 'utf8');
  return JSON.parse(raw);
}

function loadMessages() {
  if (!fs.existsSync(MESSAGES_PATH)) {
    return {};
  }
  const raw = fs.readFileSync(MESSAGES_PATH, 'utf8');
  const parsed = JSON.parse(raw);
  if (parsed?.properties && typeof parsed.properties === 'object') {
    return Object.entries(parsed.properties).reduce((acc, [key, value]) => {
        if (value && typeof value.const === 'string') {
          acc[key] = value.const;
        }
        return acc;
      }, {});
  }
  return parsed;
}

function escapeString(value) {
  return value.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
}

function toTsType(property) {
  const { type } = property;
  if (Array.isArray(type)) {
    const union = type.map((t) => toTsType({ type: t }));
    return union.join(' | ');
  }
  switch (type) {
    case 'string':
      return 'string';
    case 'boolean':
      return 'boolean';
    case 'number':
    case 'integer':
      return 'number';
    case 'array': {
      const itemType = property.items ? toTsType(property.items) : 'unknown';
      return `${itemType}[]`;
    }
    case 'null':
      return 'null';
    default:
      return 'unknown';
  }
}

function formatDefaultValue(value) {
  if (typeof value === 'string') {
    return `'${escapeString(value)}'`;
  }
  if (Array.isArray(value)) {
    if (value.length === 0) return '[]';
    return `[${value.map((item) => formatDefaultValue(item)).join(', ')}]`;
  }
  if (value === null) return 'null';
  if (typeof value === 'boolean' || typeof value === 'number') {
    return String(value);
  }
  return 'undefined';
}

function generateContent(schema) {
  const properties = schema.properties ?? {};
  const sectionMap = new Map();
  const fieldEntries = [];

  Object.entries(properties).forEach(([name, prop]) => {
    const section = prop['x-section'] ?? 'clinico';
    if (!sectionMap.has(section)) {
      sectionMap.set(section, []);
    }
    sectionMap.get(section).push(name);
    fieldEntries.push({
      name,
      type: toTsType(prop),
      defaultValue: formatDefaultValue(prop.default),
      section,
    });
  });

  const sections = Array.from(sectionMap.keys());

  const lines = [];
  lines.push('/* eslint-disable */');
  lines.push('// This file is auto-generated by scripts/generate-case-wizard-types.js');
  lines.push('// Do not edit manually.\n');

  lines.push(
    `export const CASE_WIZARD_SECTION_IDS = ${JSON.stringify(sections)} as const;`,
  );
  lines.push(
    'export type CaseWizardSectionId = typeof CASE_WIZARD_SECTION_IDS[number];\n',
  );

  lines.push('export type CaseWizardFlat = {');
  fieldEntries.forEach((entry) => {
    lines.push(`  ${entry.name}: ${entry.type};`);
  });
  lines.push('};\n');

  lines.push('export type CaseWizardFieldKey = keyof CaseWizardFlat;\n');

  lines.push('export const CASE_WIZARD_FLAT_DEFAULTS: CaseWizardFlat = {');
  fieldEntries.forEach((entry) => {
    lines.push(`  ${entry.name}: ${entry.defaultValue},`);
  });
  lines.push('};\n');

  lines.push(
    'export const CASE_WIZARD_SECTIONS = {',
  );
  sectionMap.forEach((fields, section) => {
    lines.push(`  ${section}: ${JSON.stringify(fields)} as const,`);
  });
  lines.push(
    `} as const satisfies Record<CaseWizardSectionId, readonly CaseWizardFieldKey[]>;\n`,
  );

  lines.push('export const CASE_WIZARD_FIELD_SECTION = {');
  fieldEntries.forEach((entry) => {
    lines.push(`  ${entry.name}: '${entry.section}',`);
  });
  lines.push(
    `} as const satisfies Record<CaseWizardFieldKey, CaseWizardSectionId>;\n`,
  );

  return `${lines.join('\n')}`;
}

function writeOutput(content) {
  ensureDir(path.dirname(OUTPUT_PATH));
  fs.writeFileSync(OUTPUT_PATH, `${content}\n`);
}

function ensureDir(dir) {
  fs.mkdirSync(dir, { recursive: true });
}

function formatMessagesModule(messages) {
  const lines = [];
  lines.push('/* eslint-disable */');
  lines.push('// This file is auto-generated by scripts/generate-case-wizard-types.js');
  lines.push('// Do not edit manually.\n');

  const entries = Object.entries(messages).map(
    ([key, value]) => `  ${key}: '${escapeString(String(value))}',`,
  );
  lines.push('export const CASE_WIZARD_MESSAGES = {');
  lines.push(...entries);
  lines.push('} as const;\n');
  lines.push(
    'export type CaseWizardMessageKey = keyof typeof CASE_WIZARD_MESSAGES;\n',
  );
  lines.push(
    'export const getCaseWizardMessage = (key: CaseWizardMessageKey) => CASE_WIZARD_MESSAGES[key];',
  );
  return `${lines.join('\n')}\n`;
}

function writeMessages(messages) {
  const content = formatMessagesModule(messages);

  ensureDir(path.dirname(FRONT_MESSAGES_OUTPUT_PATH));
  fs.writeFileSync(FRONT_MESSAGES_OUTPUT_PATH, content);

  ensureDir(path.dirname(BACKEND_MESSAGES_OUTPUT_PATH));
  fs.writeFileSync(BACKEND_MESSAGES_OUTPUT_PATH, content);
}

function main() {
  const schema = loadSchema();
  const messages = loadMessages();
  const content = generateContent(schema);
  writeOutput(content);
  if (Object.keys(messages).length > 0) {
    writeMessages(messages);
  }
  // eslint-disable-next-line no-console
  console.log(
    `Generated case wizard types with ${Object.keys(
      schema.properties ?? {},
    ).length} fields`,
  );
}

main();
